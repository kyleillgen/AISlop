<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Cat vs Cucumber</title>
  <style>
    canvas { background: #eef; display: block; margin: 0 auto; }
  </style>
</head>
<body>
<canvas id="game" width="400" height="400"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const player = {x:200, y:200, size:20, color:'pink', speed:2};
const enemy = {x:0, y:0, size:20, color:'green', speed:1.5};
const kibble = {x:0, y:0, size:10, color:'brown'};
const originalWidth = canvas.width;
const originalHeight = canvas.height;
let playArea = {x:0, y:0, width:originalWidth, height:originalHeight};
let score = 0;
let highScore = parseInt(localStorage.getItem('highScore'), 10) || 0;
let gameOver = false;
let keys = {};
let sprintTimer = 0;
let restartTimer = null;
let playAgainBox = {x:0, y:0, width:0, height:0};

function updatePlayArea() {
  const shrinkSteps = Math.floor(score / 20);
  const factor = Math.pow(0.95, shrinkSteps);
  playArea.width = originalWidth * factor;
  playArea.height = originalHeight * factor;
  playArea.x = (originalWidth - playArea.width) / 2;
  playArea.y = (originalHeight - playArea.height) / 2;
}

function spawnKibble() {
  kibble.x = playArea.x + Math.random() * (playArea.width - kibble.size);
  kibble.y = playArea.y + Math.random() * (playArea.height - kibble.size);
}

function spawnEnemy() {
  do {
    enemy.x = playArea.x + Math.random() * (playArea.width - enemy.size);
    enemy.y = playArea.y + Math.random() * (playArea.height - enemy.size);
  } while (
    Math.hypot(
      enemy.x + enemy.size / 2 - (player.x + player.size / 2),
      enemy.y + enemy.size / 2 - (player.y + player.size / 2)
    ) < enemy.size / 2 + player.size / 2 + 5
  );
}

updatePlayArea();
spawnEnemy();
spawnKibble();

document.addEventListener('keydown', e => {
  if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) e.preventDefault();
  keys[e.key] = true;
  if (e.key === 's' && sprintTimer === 0) {
    sprintTimer = 120; // hidden sprint ability
    player.speed = 4;
  }
  if (gameOver && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key) && !restartTimer) {
    restartTimer = setTimeout(resetGame, 500);
  }
});

document.addEventListener('keyup', e => {
  keys[e.key] = false;
  if (restartTimer) {
    clearTimeout(restartTimer);
    restartTimer = null;
  }
});

canvas.addEventListener('click', e => {
  if (!gameOver) return;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  if (x >= playAgainBox.x && x <= playAgainBox.x + playAgainBox.width &&
      y >= playAgainBox.y && y <= playAgainBox.y + playAgainBox.height) {
    resetGame();
  }
});

function resetGame() {
  if (restartTimer) {
    clearTimeout(restartTimer);
    restartTimer = null;
  }
  gameOver = false;
  score = 0;
  updatePlayArea();
  player.x = playArea.x + playArea.width / 2;
  player.y = playArea.y + playArea.height / 2;
  spawnEnemy();
  sprintTimer = 0;
  player.speed = 2;
  spawnKibble();
  keys = {};
  requestAnimationFrame(update);
}

function update() {
  if (keys['ArrowUp']) player.y -= player.speed;
  if (keys['ArrowDown']) player.y += player.speed;
  if (keys['ArrowLeft']) player.x -= player.speed;
  if (keys['ArrowRight']) player.x += player.speed;

  player.x = Math.max(playArea.x, Math.min(playArea.x + playArea.width - player.size, player.x));
  player.y = Math.max(playArea.y, Math.min(playArea.y + playArea.height - player.size, player.y));

  const dx = player.x - enemy.x;
  const dy = player.y - enemy.y;
  const dist = Math.hypot(dx, dy);
  if (dist !== 0) {
    enemy.x += (dx / dist) * enemy.speed;
    enemy.y += (dy / dist) * enemy.speed;
  }
  enemy.x = Math.max(playArea.x, Math.min(playArea.x + playArea.width - enemy.size, enemy.x));
  enemy.y = Math.max(playArea.y, Math.min(playArea.y + playArea.height - enemy.size, enemy.y));

  if (player.x < kibble.x + kibble.size &&
      player.x + player.size > kibble.x &&
      player.y < kibble.y + kibble.size &&
      player.y + player.size > kibble.y) {
    score++;
    updatePlayArea();
    spawnKibble();
    player.x = Math.max(playArea.x, Math.min(playArea.x + playArea.width - player.size, player.x));
    player.y = Math.max(playArea.y, Math.min(playArea.y + playArea.height - player.size, player.y));
    enemy.x = Math.max(playArea.x, Math.min(playArea.x + playArea.width - enemy.size, enemy.x));
    enemy.y = Math.max(playArea.y, Math.min(playArea.y + playArea.height - enemy.size, enemy.y));
  }

  if (player.x < enemy.x + enemy.size &&
      player.x + player.size > enemy.x &&
      player.y < enemy.y + enemy.size &&
      player.y + player.size > enemy.y) {
    gameOver = true;
    keys = {};
    if (score > highScore) {
      highScore = score;
      localStorage.setItem('highScore', highScore);
    }
  }

  if (sprintTimer > 0) {
    sprintTimer--;
    if (sprintTimer === 0) player.speed = 2;
  }

  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.strokeStyle = 'black';
  ctx.strokeRect(playArea.x, playArea.y, playArea.width, playArea.height);
  ctx.fillStyle = kibble.color;
  ctx.fillRect(kibble.x, kibble.y, kibble.size, kibble.size);
  ctx.fillStyle = player.color;
  ctx.fillRect(player.x, player.y, player.size, player.size);
  ctx.fillStyle = enemy.color;
  ctx.fillRect(enemy.x, enemy.y, enemy.size, enemy.size);

  ctx.fillStyle = 'green';
  ctx.font = '16px sans-serif';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillText('High Score: ' + highScore, 10, 10);
  ctx.fillStyle = 'black';
  ctx.textAlign = 'right';
  ctx.fillText('Score: ' + score, canvas.width - 10, 10);

  if (gameOver) {
    ctx.fillStyle = 'black';
    ctx.font = '24px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'alphabetic';
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    ctx.fillText('Game Over! Score: ' + score, centerX, centerY);
    const playAgainText = 'Play again?';
    ctx.font = '20px sans-serif';
    ctx.textBaseline = 'top';
    const playAgainY = centerY + 30;
    ctx.fillText(playAgainText, centerX, playAgainY);
    const textWidth = ctx.measureText(playAgainText).width;
    playAgainBox = {
      x: centerX - textWidth / 2,
      y: playAgainY,
      width: textWidth,
      height: 24
    };
  } else {
    ctx.textBaseline = 'alphabetic';
    requestAnimationFrame(update);
  }
}
update();
</script>
</body>
</html>
