<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Cat vs Cucumber</title>
  <style>
    canvas { background: #eef; display: block; margin: 0 auto; }
  </style>
</head>
<body>
<canvas id="game" width="400" height="400"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = Math.min(window.innerWidth, window.innerHeight);
canvas.height = canvas.width;
const player = {x:canvas.width / 2, y:canvas.height / 2, size:20, color:'pink', baseSpeed:2, speed:2};
const enemy = {x:0, y:0, size:20, color:'green', baseSpeed:1.5, speed:1.5};
const kibble = {x:0, y:0, size:10, color:'brown'};
const originalWidth = canvas.width;
const originalHeight = canvas.height;
let playArea = {x:0, y:0, width:originalWidth, height:originalHeight};
let score = 0;
let highScore = parseInt(localStorage.getItem('highScore'), 10) || 0;
let gameOver = false;
let keys = {};
let sprintTimer = 0;
let restartTimer = null;
let playAgainBox = {x:0, y:0, width:0, height:0};
let speedScale = canvas.width / 400;
let powerUp = null;
let invincibleTimer = 0;
let speedBoostTimer = 0;
let scoreMultiplierTimer = 0;
let invincibleHue = 0;
const POWERUP_DURATION = 7 * 60; // 7 seconds at 60fps

function updateSpeedScale() {
  speedScale = canvas.width / 400;
  player.speed = player.baseSpeed * speedScale;
  if (speedBoostTimer > 0) player.speed *= 1.5;
  if (sprintTimer > 0) player.speed *= 2;
  enemy.speed = enemy.baseSpeed * speedScale;
}

function updatePlayArea() {
  const shrinkSteps = Math.floor(score / 20);
  const factor = Math.pow(0.95, shrinkSteps);
  playArea.width = originalWidth * factor;
  playArea.height = originalHeight * factor;
  playArea.x = (originalWidth - playArea.width) / 2;
  playArea.y = (originalHeight - playArea.height) / 2;
}

function spawnKibble() {
  kibble.x = playArea.x + Math.random() * (playArea.width - kibble.size);
  kibble.y = playArea.y + Math.random() * (playArea.height - kibble.size);
}

function spawnEnemy() {
  do {
    enemy.x = playArea.x + Math.random() * (playArea.width - enemy.size);
    enemy.y = playArea.y + Math.random() * (playArea.height - enemy.size);
  } while (
    Math.hypot(
      enemy.x + enemy.size / 2 - (player.x + player.size / 2),
      enemy.y + enemy.size / 2 - (player.y + player.size / 2)
    ) < enemy.size / 2 + player.size / 2 + 5
  );
}

function spawnPowerUp() {
  const types = ['invincibility', 'speed', 'score'];
  const type = types[Math.floor(Math.random() * types.length)];
  const size = kibble.size * 2;
  const color = type === 'invincibility' ? 'yellow' : type === 'speed' ? 'blue' : 'purple';
  powerUp = {
    type,
    color,
    size,
    x: playArea.x + Math.random() * (playArea.width - size),
    y: playArea.y + Math.random() * (playArea.height - size),
    timer: 300
  };
}

updatePlayArea();
player.x = playArea.x + playArea.width / 2;
player.y = playArea.y + playArea.height / 2;
spawnEnemy();
spawnKibble();
updateSpeedScale();

document.addEventListener('keydown', e => {
  if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) e.preventDefault();
  keys[e.key] = true;
  if (e.key === 's' && sprintTimer === 0) {
    sprintTimer = 120; // hidden sprint ability
    updateSpeedScale();
  }
  if (gameOver && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key) && !restartTimer) {
    restartTimer = setTimeout(resetGame, 500);
  }
});

document.addEventListener('keyup', e => {
  keys[e.key] = false;
  if (restartTimer) {
    clearTimeout(restartTimer);
    restartTimer = null;
  }
});

canvas.addEventListener('click', e => {
  if (!gameOver) return;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  if (x >= playAgainBox.x && x <= playAgainBox.x + playAgainBox.width &&
      y >= playAgainBox.y && y <= playAgainBox.y + playAgainBox.height) {
    resetGame();
  }
});

function resetGame() {
  if (restartTimer) {
    clearTimeout(restartTimer);
    restartTimer = null;
  }
  gameOver = false;
  score = 0;
  updatePlayArea();
  player.x = playArea.x + playArea.width / 2;
  player.y = playArea.y + playArea.height / 2;
  spawnEnemy();
  sprintTimer = 0;
  invincibleTimer = 0;
  speedBoostTimer = 0;
  scoreMultiplierTimer = 0;
  powerUp = null;
  updateSpeedScale();
  spawnKibble();
  keys = {};
  requestAnimationFrame(update);
}

function update() {
  if (keys['ArrowUp']) player.y -= player.speed;
  if (keys['ArrowDown']) player.y += player.speed;
  if (keys['ArrowLeft']) player.x -= player.speed;
  if (keys['ArrowRight']) player.x += player.speed;

  player.x = Math.max(playArea.x, Math.min(playArea.x + playArea.width - player.size, player.x));
  player.y = Math.max(playArea.y, Math.min(playArea.y + playArea.height - player.size, player.y));

  const dx = player.x - enemy.x;
  const dy = player.y - enemy.y;
  const dist = Math.hypot(dx, dy);
  if (dist !== 0) {
    enemy.x += (dx / dist) * enemy.speed;
    enemy.y += (dy / dist) * enemy.speed;
  }
  enemy.x = Math.max(playArea.x, Math.min(playArea.x + playArea.width - enemy.size, enemy.x));
  enemy.y = Math.max(playArea.y, Math.min(playArea.y + playArea.height - enemy.size, enemy.y));

  if (player.x < kibble.x + kibble.size &&
      player.x + player.size > kibble.x &&
      player.y < kibble.y + kibble.size &&
      player.y + player.size > kibble.y) {
    score += scoreMultiplierTimer > 0 ? 2 : 1;
    updatePlayArea();
    spawnKibble();
    player.x = Math.max(playArea.x, Math.min(playArea.x + playArea.width - player.size, player.x));
    player.y = Math.max(playArea.y, Math.min(playArea.y + playArea.height - player.size, player.y));
    enemy.x = Math.max(playArea.x, Math.min(playArea.x + playArea.width - enemy.size, enemy.x));
    enemy.y = Math.max(playArea.y, Math.min(playArea.y + playArea.height - enemy.size, enemy.y));
  }

  if (player.x < enemy.x + enemy.size &&
      player.x + player.size > enemy.x &&
      player.y < enemy.y + enemy.size &&
      player.y + player.size > enemy.y &&
      invincibleTimer === 0) {
    gameOver = true;
    keys = {};
    if (score > highScore) {
      highScore = score;
      localStorage.setItem('highScore', highScore);
    }
  }

  if (powerUp &&
      player.x < powerUp.x + powerUp.size &&
      player.x + player.size > powerUp.x &&
      player.y < powerUp.y + powerUp.size &&
      player.y + player.size > powerUp.y) {
    if (powerUp.type === 'invincibility') {
      invincibleTimer = POWERUP_DURATION;
    } else if (powerUp.type === 'speed') {
      speedBoostTimer = POWERUP_DURATION;
      updateSpeedScale();
    } else if (powerUp.type === 'score') {
      scoreMultiplierTimer = POWERUP_DURATION;
    }
    powerUp = null;
  }

  if (powerUp) {
    powerUp.timer--;
    if (powerUp.timer === 0) powerUp = null;
  } else if (score >= 5 && Math.random() < 0.005) {
    spawnPowerUp();
  }

  if (sprintTimer > 0) {
    sprintTimer--;
    if (sprintTimer === 0) updateSpeedScale();
  }

  if (invincibleTimer > 0) invincibleTimer--;
  if (speedBoostTimer > 0) {
    speedBoostTimer--;
    if (speedBoostTimer === 0) updateSpeedScale();
  }
  if (scoreMultiplierTimer > 0) scoreMultiplierTimer--;

  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.strokeStyle = 'black';
  ctx.strokeRect(playArea.x, playArea.y, playArea.width, playArea.height);
  ctx.fillStyle = kibble.color;
  ctx.fillRect(kibble.x, kibble.y, kibble.size, kibble.size);
  if (powerUp) {
    ctx.fillStyle = powerUp.color;
    ctx.fillRect(powerUp.x, powerUp.y, powerUp.size, powerUp.size);
  }
  let playerDrawColor = player.color;
  if (invincibleTimer > 0) {
    playerDrawColor = `hsl(${invincibleHue},100%,70%)`;
    invincibleHue = (invincibleHue + 20) % 360;
  }
  ctx.fillStyle = playerDrawColor;
  ctx.fillRect(player.x, player.y, player.size, player.size);
  ctx.fillStyle = enemy.color;
  ctx.fillRect(enemy.x, enemy.y, enemy.size, enemy.size);

  ctx.fillStyle = 'green';
  ctx.font = '16px sans-serif';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillText('High Score: ' + highScore, 10, 10);
  ctx.fillStyle = 'black';
  ctx.textAlign = 'right';
  ctx.fillText('Score: ' + score, canvas.width - 10, 10);

  if (gameOver) {
    ctx.fillStyle = 'black';
    ctx.font = '24px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'alphabetic';
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    ctx.fillText('Game Over! Score: ' + score, centerX, centerY);
    const playAgainText = 'Play again?';
    ctx.font = '20px sans-serif';
    ctx.textBaseline = 'top';
    const playAgainY = centerY + 30;
    ctx.fillText(playAgainText, centerX, playAgainY);
    const textWidth = ctx.measureText(playAgainText).width;
    playAgainBox = {
      x: centerX - textWidth / 2,
      y: playAgainY,
      width: textWidth,
      height: 24
    };
  } else {
    ctx.textBaseline = 'alphabetic';
    requestAnimationFrame(update);
  }
}
update();
</script>
</body>
</html>
